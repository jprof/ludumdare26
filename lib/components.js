// Generated by CoffeeScript 1.6.2
(function() {
  Crafty.c("Enemy", {
    init: function() {
      this.requires('Canvas, Color, 2D, Collision, ChasePlayer, Sprite, pigeon');
      this.h = 40;
      this.w = 40;
      return this.collision(new Crafty.polygon([0, 0], [40, 0], [40, 40], [0, 40]));
    }
  });

  Crafty.c('ChasePlayer', {
    init: function() {
      this.requires('2D');
      this.bind('EnterFrameActive', this._enterframeActive);
      this.speed = 1;
    },
    _enterframeActive: function() {
      var ang, ex, ey, px, py;

      px = Window.playerEntity.x + Window.playerEntity.w / 2;
      py = Window.playerEntity.y + Window.playerEntity.h / 2;
      ex = this.x + this.w / 2;
      ey = this.y + this.h / 2;
      ang = Math.atan2(py - ey, px - ex);
      this.targetX += this.speed * Math.cos(ang);
      this.targetY += this.speed * Math.sin(ang);
      this.x += (this.targetX - this.x) * .2;
      this.y += (this.targetY - this.y) * .2;
      this.z = this.y + this.h;
    }
  });

  Crafty.c('GameMaster', {
    init: function() {
      return this.bind("KeyDown", this._keydown);
    },
    _keydown: function(e) {
      switch (e.key) {
        case 69:
          return this.spawnEnemy();
        case 79:
          return this.spawnBuilding();
        case 82:
          return this.spawnRat();
        case 66:
          return Window.playerEntity.blowAway(1);
        case 78:
          return Crafty("LevelLoader").nextLevel();
      }
    },
    spawnEnemy: function() {
      var randX, randY;

      randX = 800 * Math.random();
      randY = 600 * Math.random();
      this.enemySquare = Crafty.e('Enemy');
      return this.enemySquare.attr({
        x: randX,
        y: randY,
        targetX: randX,
        targetY: randY
      });
    },
    spawnBuilding: function() {
      var randX, randY;

      randX = 800 * Math.random();
      randY = 600 * Math.random();
      if (Math.random() > .5) {
        this.obstacle = Crafty.e('Building1');
      } else {
        this.obstacle = Crafty.e('Building2');
      }
      return this.obstacle.attr({
        x: randX,
        y: randY,
        z: 1
      });
    },
    spawnRat: function() {
      var randLeft, randRight, randStartX, randY;

      randLeft = 750 * Math.random();
      randRight = Crafty.math.randomNumber(randLeft, 795);
      randY = 600 * Math.random();
      randStartX = Crafty.math.randomNumber(randLeft + 1, randRight - 1);
      this.rat = Crafty.e('Rat');
      this.rat.attr({
        x: randStartX,
        y: randY,
        z: 2,
        left: randLeft,
        right: randRight
      });
      if (randStartX < randRight) {
        return this.rat.patrolState = this.rat.HorizontalPatrolStates.patrolRight;
      } else {
        return this.rat.patrolState = this.rat.HorizontalPatrolStates.patrolLeft;
      }
    }
  });

  Crafty.c("Rat", {
    init: function() {
      this.requires('Canvas, Color, Collision, HorizontalPatrol, rat, SpriteAnimation');
      this.w = 100;
      this.h = 60;
      this.collision(new Crafty.polygon([20, 15], [80, 15], [80, 55], [20, 55]));
      this.color('none');
      return this.bind('EnterFrameActive', this._ratEnterFrameActive);
    },
    _hitObstacle: function() {
      return this._reversePatrol();
    },
    _ratEnterFrameActive: function() {
      if (this.prevPatrolState !== this.patrolState) {
        this.stop();
        switch (this.patrolState) {
          case this.HorizontalPatrolStates.idleLeft:
            this.animate('idleLeft', 0, 3, 1);
            this.animate('idleLeft', 25, 0);
            break;
          case this.HorizontalPatrolStates.idleRight:
            this.animate('idleRight', 0, 2, 1);
            this.animate('idleRight', 25, 0);
            break;
          case this.HorizontalPatrolStates.patrolLeft:
            this.animate('walkLeft', 0, 1, 3);
            this.animate('walkLeft', 25, -1);
            break;
          case this.HorizontalPatrolStates.patrolRight:
            this.animate('walkRight', 0, 0, 3);
            this.animate('walkRight', 25, -1);
        }
      }
      return this.prevPatrolState = this.patrolState;
    }
  });

  Crafty.c('Obstacle', {
    init: function() {
      this.requires('Canvas, Color, 2D, Collision');
      this.onHit("PlayerCharacter", this._onHit);
      this.onHit("Rat", this._onHitRat);
      this.onHit("Enemy", this._onHit);
    },
    _onHitRat: function(rats) {
      var rat, _i, _len;

      for (_i = 0, _len = rats.length; _i < _len; _i++) {
        rat = rats[_i];
        rat.obj._hitObstacle();
      }
      return this._onHit(rats);
    },
    _onHit: function(targets) {
      var dx, dy, maxX, maxY, minX, minY, objCenterX, objCenterY, objH, objW, objX, objY, playerCenterX, playerCenterY, playerH, playerW, playerX, playerY, point, target, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;

      minX = 10000000;
      maxX = -10000000;
      minY = 10000000;
      maxY = -10000000;
      _ref = this.map.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        minX = Math.min(minX, point[0]);
        maxX = Math.max(maxX, point[0]);
        minY = Math.min(minY, point[1]);
        maxY = Math.max(maxY, point[1]);
      }
      objX = minX;
      objY = minY;
      objW = maxX - minX;
      objH = maxY - minY;
      objCenterX = (maxX + minX) / 2;
      objCenterY = (maxY + minY) / 2;
      for (_j = 0, _len1 = targets.length; _j < _len1; _j++) {
        target = targets[_j];
        minX = 10000000;
        maxX = -10000000;
        minY = 10000000;
        maxY = -10000000;
        _ref1 = target.obj.map.points;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          point = _ref1[_k];
          minX = Math.min(minX, point[0]);
          maxX = Math.max(maxX, point[0]);
          minY = Math.min(minY, point[1]);
          maxY = Math.max(maxY, point[1]);
        }
        playerX = minX;
        playerY = minY;
        playerW = maxX - minX;
        playerH = maxY - minY;
        playerCenterX = playerX + playerW / 2;
        playerCenterY = playerY + playerH / 2;
        dx = playerCenterX - objCenterX;
        dy = playerCenterY - objCenterY;
        if (playerCenterY < objH / objW * (playerCenterX - objCenterX) + objCenterY) {
          if (playerCenterY < -objH / objW * (playerCenterX - objCenterX) + objCenterY) {
            target.obj.y = target.obj.targetY = objY - (playerY + playerH - target.obj.y);
          } else {
            target.obj.x = target.obj.targetX = objX + objW - (playerX - target.obj.x);
          }
        } else {
          if (playerCenterY < -objH / objW * (playerCenterX - objCenterX) + objCenterY) {
            target.obj.x = target.obj.targetX = objX - (playerX + playerW - target.obj.x);
          } else {
            target.obj.y = target.obj.targetY = objY + objH - (playerY - target.obj.y);
          }
        }
      }
    }
  });

  Crafty.c('Building1', {
    init: function() {
      this.requires('Obstacle, Sprite, building1');
      this.w = this.h = 100;
      this.collision(new Crafty.polygon([10, 65], [95, 65], [95, 100], [10, 100]));
      return this.color('none');
    }
  });

  Crafty.c('Building2', {
    init: function() {
      this.requires('Obstacle, Sprite, building2');
      this.w = 200;
      this.h = 150;
      this.collision(new Crafty.polygon([15, 120], [190, 120], [190, 150], [15, 150]));
      return this.color('none');
    }
  });

  Crafty.c('Border', {
    init: function() {
      this.requires('Obstacle, Sprite, building1');
      this.w = this.h = 100;
      this.collision(new Crafty.polygon([0, 0], [100, 0], [100, 100], [0, 100]));
      return this.color('none');
    }
  });

  Crafty.c('Prize', {
    init: function() {
      this.requires("Canvas, 2D, Color, Collision, potato, SpriteAnimation");
      this.w = this.h = 60;
      this.collision(new Crafty.polygon([0, 0], [60, 0], [60, 80], [0, 80]));
      this.animate('animate', 0, 0, 1);
      this.animate('animate', 20, -1);
    }
  });

  Crafty.c('Freezable', {
    FreezableStates: {
      frozen: 0,
      idle: 1,
      active: 2
    },
    init: function() {
      this.bind("KeyDown", this._keydown);
      this.bind("EnterFrame", this._enterframe);
      this.freezableState = this.FreezableStates.frozen;
    },
    _keydown: function(e) {
      switch (this.freezableState) {
        case this.FreezableStates.idle:
          return Crafty.trigger('KeydownIdle', e);
        case this.FreezableStates.active:
          return Crafty.trigger('KeydownActive', e);
      }
    },
    _enterframe: function() {
      switch (this.freezableState) {
        case this.FreezableStates.idle:
          return Crafty.trigger('EnterFrameIdle');
        case this.FreezableStates.active:
          return Crafty.trigger('EnterFrameActive');
      }
    }
  });

  Crafty.c('HorizontalPatrol', {
    HorizontalPatrolStates: {
      idleLeft: 0,
      idleRight: 1,
      patrolLeft: 2,
      patrolRight: 3
    },
    init: function() {
      this.requires('2D');
      this.speed = 1;
      this.MAX_PAUSE = 50;
      this.pauseCounter = 0;
      return this.bind('EnterFrameActive', this._enterframeActive);
    },
    bounds: function(left, right) {
      this.left = left;
      this.right = right;
    },
    _wait: function() {
      if (this.pauseCounter < this.MAX_PAUSE) {
        this.pauseCounter += 1;
        return false;
      } else {
        this.pauseCounter = 0;
        return true;
      }
    },
    _enterframeActive: function() {
      switch (this.patrolState) {
        case this.HorizontalPatrolStates.idleLeft:
          if (this._wait()) {
            return this.patrolState = this.HorizontalPatrolStates.patrolRight;
          }
          break;
        case this.HorizontalPatrolStates.idleRight:
          if (this._wait()) {
            return this.patrolState = this.HorizontalPatrolStates.patrolLeft;
          }
          break;
        case this.HorizontalPatrolStates.patrolLeft:
          if (this.x < this.left) {
            return this.patrolState = this.HorizontalPatrolStates.idleLeft;
          } else {
            return this.x -= this.speed;
          }
          break;
        case this.HorizontalPatrolStates.patrolRight:
          if (this.x > this.right) {
            return this.patrolState = this.HorizontalPatrolStates.idleRight;
          } else {
            return this.x += this.speed;
          }
      }
    },
    _reversePatrol: function() {
      switch (this.patrolState) {
        case this.HorizontalPatrolStates.patrolRight:
          return this.patrolState = this.HorizontalPatrolStates.idleRight;
        case this.HorizontalPatrolStates.patrolLeft:
          return this.patrolState = this.HorizontalPatrolStates.idleLeft;
      }
    }
  });

}).call(this);
